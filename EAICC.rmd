---
title: "R Notebook"
output: html_notebook
editor_options: 
  chunk_output_type: inline
---

```{r}
library("pacman")
library("zoo")
library("ggplot2")
library("ggrepel")
library("dplyr")
library("readr")
library("caret")
p_load("here")
p_load("tidyverse")
```


```{r}
pam_file = here("Data", "pam.xlsx")
expost_pam_file = here("Data", "expost_pam.xlsx")
lulucf_file = here("Data", "lulucf.xlsx")
emissions_file = here("Data", "emissions.xlsx")
population_file = here("Data", "population_oecd.xlsx")
iso_file = here("Data", "ISO.xlsx") # Copied from IMF dataset
projection_file = here("Data", "projections.xlsx")

```

```{r}
pam_raw = readxl::read_excel(pam_file)
expost_pam_raw = readxl::read_excel(expost_pam_file)
lulucf_raw = readxl::read_excel(lulucf_file)
emissions_raw = readxl::read_excel(emissions_file)
population_raw = readxl::read_excel(population_file)
iso_raw = readxl::read_excel(iso_file) %>% unique()
projection_raw = readxl::read_excel((projection_file))

```


```{r}
#Population
population <- population_raw %>% filter(TIME==2021, SUBJECT=="TOT") %>% rename("ISO3"=LOCATION, "pop"=Value) %>% left_join(iso_raw) %>% select(ISO2, pop) %>% mutate(pop=pop*10**6)
```


```{r}
#PAM
# Filter out Policy groups to avoid duplicates
single_pams <- pam_raw %>% filter(`Single policy or measure, or group of measures`=="Single")
# Select only columns of interest
single_pams <- single_pams %>% select(Country, CountryCode, `Sector(s) affected`, `Status of implementation`, `Implementation period start`, `Implementation period finish`, c(32:47))

# # Sum up total GHG emission reduction in 2025 and group by Status of Implementation (Implemented, Planned, Adopted, Expired, NA)
# tot_pams <- single_pams %>% group_by(Country, `Status of implementation`) %>%
#   summarise(Total_GHG_Reductions_2025 = sum(`Total GHG emissions reductions in 2025 (kt CO2eq/y)`, na.rm = TRUE)) %>%
#   ungroup()

# Sum up total GHG emission reduction in 2030 and group by Status of Implementation (Implemented, Planned, Adopted, Expired, NA)
# tot_pams <- single_pams %>% group_by(Country, `Status of implementation`) %>%
#   summarise(Total_GHG_Reductions_2030 = sum(`Total GHG emissions reductions in 2030 (kt CO2eq/y)`, na.rm = TRUE)) %>%
#   ungroup() %>% left_join(tot_pams,.)

# # Sum up total GHG emission reduction in 2035 and group by Status of Implementation (Implemented, Planned, Adopted, Expired, NA)
# tot_pams <- single_pams %>% group_by(Country, `Status of implementation`) %>%
#   summarise(Total_GHG_Reductions_2035 = sum(`Total GHG emissions reductions in 2035 (kt CO2eq/y)`, na.rm = TRUE)) %>%
#   ungroup() %>% left_join(tot_pams,.)
# 
# # Sum up total GHG emission reduction in 2040 and group by Status of Implementation (Implemented, Planned, Adopted, Expired, NA)
# tot_pams <- single_pams %>% group_by(Country, `Status of implementation`) %>%
#   summarise(Total_GHG_Reductions_2040 = sum(`Total GHG emissions reductions in 2040 (kt CO2eq/y)`, na.rm = TRUE)) %>%
#   ungroup() %>% left_join(tot_pams,.)
# 
# # Overall Total of 2025 - 2040
# tot_pams <- tot_pams %>% mutate(tot_tot = rowSums(.[c(3:6)], na.rm=TRUE))

# Weight per Implementation Implemented: 30%, Adopted: 10%, Planned: 10%, Expired & NA: 0% -> overall PAM contribution to mitigation effort/potential: 50% 
# # TODO Maybe consider time until implemented? Higher weight if near future?
# tot_pams <- tot_pams %>% mutate(weight=0) %>% mutate(weight=as.numeric(ifelse(.$`Status of implementation` == "Implemented", 0.4,
#                                                           ifelse(.$`Status of implementation` == "Adopted", 0.1,
#                                                           ifelse(.$`Status of implementation` == "Planned", 0.1, .$weight)))))
# #Weighted overall total of 2025-2040
# tot_pams <- tot_pams %>% mutate(weighted_tot_tot=tot_tot*weight)

#Summarized by country until 2040 [kT CO2eq]
# per_country_tot_pams <- tot_pams %>% group_by(Country) %>% summarise(Total_Weighted_Reduction = sum(weighted_tot_tot, na.rm=TRUE)*-1) %>% ungroup() # multiply by -1 for GHG removal
# per_country_tot_pams <- per_country_tot_pams %>% rename("country"=Country)
# per_country_tot_pams <- per_country_tot_pams %>% mutate(country=ifelse(.$country=="Czech Republic",
#                                                                    "Czechia",
#                                                                    .$country))
```

```{r}
# PAMs scenario only for 2030

# Sum up total GHG emission reduction in 2030 and group by Status of Implementation (Implemented, Planned, Adopted, Expired, NA)
pams_2030 <- single_pams %>% group_by(Country, `Status of implementation`) %>%
  summarise(Total_GHG_Reductions_2030 = sum(`Total GHG emissions reductions in 2030 (kt CO2eq/y)`, na.rm = TRUE)) %>%
  ungroup()

# Weight per Implementation: Implemented: 30%, Adopted: 10%, Planned: 10%, Expired & NA: 0% -> overall PAM contribution to mitigation effort/potential: 50% 
pams_2030 <- pams_2030 %>% mutate(weight=0) %>% mutate(weight=as.numeric(ifelse(.$`Status of implementation` == "Implemented", 0.4,
                                                          ifelse(.$`Status of implementation` == "Adopted", 0.1,
                                                          ifelse(.$`Status of implementation` == "Planned", 0.1, .$weight)))))

# Weighted PAM 2030
pams_2030 <- pams_2030 %>% mutate(weighted_2030=(Total_GHG_Reductions_2030*weight))

#Summarized by country [kT CO2eq]
per_country_pams_2030 <- pams_2030 %>% group_by(Country) %>% summarise(Weighted_PAM_2030 = sum(weighted_2030, na.rm=TRUE)*-1) %>% ungroup() # multiply by -1 for GHG removal
per_country_pams_2030 <- per_country_pams_2030 %>% rename("country"=Country)
per_country_pams_2030 <- per_country_pams_2030 %>% mutate(country=ifelse(.$country=="Czech Republic",
                                                                   "Czechia",
                                                                   .$country))

```


```{r}
# Expost PAM
expost_pam_country <- expost_pam_raw %>% select(-c(1:2)) %>% t() %>% as.data.frame() %>% select(c(2,4))
names(expost_pam_country) <- c("no_expost", "expost")
expost_pam_country$country = rownames(expost_pam_country)
expost_pam_country[2][is.na(expost_pam_country[2])] <- 0

```

```{r}
# LULUCF
# Select only columns of interest
lulucf <- lulucf_raw %>% select(country, net_cost) %>% rename("lulucf"=net_cost)
lulucf <- lulucf %>% mutate(lulucf=(lulucf*1000))
lulucf <- lulucf %>% mutate(lulucf_weighted=ifelse(.$lulucf < 0,.$lulucf*0.4,.$lulucf*0.4))
#  Negative numbers are GHG removals, positive numbers are emissions of GHG through LULUCFs
```

```{r}
#GHG Projection Total inc. int. Aviation excl. LULUCF for WAM-Scenario 
# WAM also includes the additional effects of planned measures.
projection <- projection_raw %>% 
  filter((Category=="Total excluding LULUCF (incl. Int. Aviation)") &  (Year==2021) & (Gas=="Total GHG emissions (ktCO2e)") & (Scenario=="WAM")) %>%
  rename("ISO2"=CountryCode) %>% left_join(iso_raw)  %>% rename("projection"="Final/Gap-filled")
```

```{r}
# GHG Emissions in K kt CO2 eq
# Select only columns of interest
emission <- emissions_raw %>% 
  left_join(population) %>% 
  left_join(projection) %>%  
  select(country, emissions, pop, projection)

emission$emissions <- emission$emissions *1000 # [kt CO2eq] K kt -> kt CO2 eq
#emission <- emission %>% mutate(weighted_emissions=emissions*.6) # [kt CO2eq]
emission <- emission %>% mutate(weighted_projected_emissions=projection*.6)
#emission <- emission %>% mutate(weighted_emissions_pop=emissions/pop*1000*.6) # [kt CO2eq per capita]
emission <- emission %>% mutate(weighted_projected_emission_pop=projection/pop*.6) # TODO(?) [kt CO2eq per capita] 
```

```{r}
# Join all tables into one
all_data <- per_country_pams_2030 %>% 
  left_join(expost_pam_country) %>% 
  left_join(lulucf) %>% 
  left_join(emission)

# Calculate netto for each country (weighted impact + mitigation (mitigation is negative): 
# net = (0.6*proj.emission + 0.4*LULUCF sources) - (0.4*LULUCF sinks + 0.4*implemented PAMs + 0.1*adopted PAMs + 0.1*planned PAMs)
all_data <- all_data %>% 
  mutate(netto = rowSums(.[c(2,6,10)],na.rm=TRUE))
```

Drop rows with NA values: Unfortunately, Norway has no WAM predictions!!!
```{r}
all_data <- drop_na(all_data)
```

```{r}
# # Naive Normalization attempt (does not work!)
# eaicc <- function(all_countries) {
#   global_sum = abs(sum(all_countries$netto))
#   all_countries <- all_countries %>% mutate("eaicc_score"=.$netto/global_sum)
#   return(all_countries)
# }
# 
# result <- eaicc(all_data)

# # Attempt without function
# global_sum = abs(sum(all_data$netto))
# print(global_sum)
# all_countries <- all_data %>% mutate("eaicc_score"=.$netto/global_sum)
```

```{r}
# Calculating scores for impact and mitigation component/dimension (> for later mapping)
# Impact only described through weighted GHG emissions 
# Mitigation: total mitigation is describes through LULUCFs & PAMs 2030 (minus the emissions through LULUCFs)
all_data <- all_data %>% mutate(tot_mit = rowSums(.[c(2,6)],na.rm=TRUE))

# Creating new df with relevant columns
eaicc <- all_data %>% select(country, weighted_projected_emissions, tot_mit, pop)
eaicc <- eaicc %>% mutate(tot_mit_reverse = tot_mit * -1) %>% 
  mutate(netto = rowSums(.[c(2,3)], na.rm=TRUE)) #impact - mitigation

# Per Capita
eaicc_per_capita <- all_data %>% select(country, weighted_projected_emissions, tot_mit, pop)
eaicc_per_capita <- eaicc_per_capita %>% 
  mutate(tot_mit_reverse = tot_mit * -1) %>% 
  mutate(netto_pop = rowSums(.[c(2,3)], na.rm=TRUE)/pop) %>% #impact - mitigation 
  mutate(weighted_projected_emissions_pop = weighted_projected_emissions/pop) %>%
  mutate(tot_mit_pop = tot_mit / pop) %>%
  mutate(tot_mit_reverse_pop = tot_mit_pop * -1)

# Normalization function 
fun_range <- function(x) {
  (x - min(x)) / (max(x) - min(x))
}

# For mitigation (reverse normalization to assign most negative values to 1 = highest mitigation efforts)
fun_range_reverse <- function(x) {
  1 - (x - min(x)) / (max(x) - min(x))
}

# Use normalization function to scale values between 0 and 1
eaicc$impact <- fun_range(x = eaicc$weighted_projected_emissions)
eaicc$mitigation <- fun_range_reverse(x = eaicc$tot_mit)
eaicc$EAICC <- fun_range_reverse(x = eaicc$netto)

eaicc_per_capita$EAICC_pop <- fun_range_reverse(x = eaicc_per_capita$netto_pop)
```

```{r clean env}
# Keep working env clean
rm(all_data, emission, emissions_raw, expost_pam_country, expost_pam_raw, iso_raw,
   lulucf, lulucf_raw, pam_raw, pams_2030, per_country_pams_2030, population, population_raw,
   projection, projection_raw, single_pams, emissions_file, expost_pam_file, iso_file, lulucf_file, pam_file, population_file, projection_file)
```


```{r Mapping}
# Define custom color gradient
custom_colors <- c("black", "yellow", "green")

netline <- ggplot(eaicc) +
  geom_point(aes(weighted_projected_emissions, tot_mit_reverse, color = EAICC)) +
  xlab("Climate Change Impact: \n Projected GHG emissions for 2030 [kT CO2 eq]") +
  ylab("Climate change Mitigation Potential in 2030 [kT CO2 eq]") +
  ggtitle("European Climate Change Accountability Index") +
  geom_abline(slope = 1, linetype = "dashed") +
  geom_text(x = 200000, y = 180000, label = "Net-Zero-Goal 2030", hjust = -0.1, vjust = -0.1, size = 2, angle = 37) +
  geom_text_repel(aes(weighted_projected_emissions, tot_mit_reverse, label = country), size = 2, force = 1, max.overlaps = 50) +
  scale_color_gradientn(colors = custom_colors, values = c(0, 0.5, 1), guide = "none") +
  theme_bw()



# Per capita
netline_per_capita <- ggplot(eaicc_per_capita) +
  geom_point(aes(weighted_projected_emissions_pop, tot_mit_reverse_pop, color = EAICC_pop)) +
  xlab("Climate Change Impact per Capita: \n Projected GHG emissions for 2030 [kT CO2 eq]") +
  ylab("Climate change Mitigation Potential: \n per capita in 2030 [kT CO2 eq]") + # Mitigation potential assuming LULUCFs to stay approximately constant
  ggtitle("European Climate Change Accountability Index per capita") + # Change title!!!!!!
  geom_abline(slope = 1, linetype = "dashed") +
  # geom_text(x = 0, y = 0, label = "Net-Zero-Goal 2030", hjust = -0.1, vjust = -0.1, size = 2, angle = 10) +
  geom_text_repel(aes(weighted_projected_emissions_pop, tot_mit_reverse_pop, label = country), 
                  size = 2, force = 1, max.overlaps = 50) +
  scale_color_gradientn(colors = custom_colors, values = c(0, 0.5, 1), guide = "none") +
  theme_bw()

netline
netline_per_capita

ggsave("plots/netline.png", plot = netline, width = 10, height = 6, dpi = 300)
ggsave("plots/netline_per_capita.png", plot = netline_per_capita, width = 10, height = 6, dpi = 300)
```


```{r Index Score}

# The Index Score is calculated as the minimal distance of a point to the net-zero line.
# Positive values lie above the line an negative values below. There is no min or max value, however a higher index equals a better perfomance. 

# X: weighted_projected_emissions Y: tot_mit_reverse,
# y = x

# Function to calculate the minimum distance
min_distance_to_line <- function(x, y) {
  distance <- (y - x)/ sqrt(2)  # Perpendicular distance formula
  return(distance)
}

# When comparing multiple years replace max(score) with absolute value
scale_index <- function(score) {
  zero <- ((0 + abs(min(score)))/max(score)) #defines net zero boundary
  score <- ((score + abs(min(score)))/max(score))
  
  zero <- zero/max(score)
  score <- round((score/max(score) - zero) * 100,1)
  return(score)
}

# Calculate the minimum distance for each point
eaicc <- eaicc |>
  mutate(score = min_distance_to_line(eaicc$weighted_projected_emissions, eaicc$tot_mit_reverse))

eaicc_per_capita  <- eaicc_per_capita |>
  mutate(score = min_distance_to_line(eaicc_per_capita$weighted_projected_emissions_pop, eaicc_per_capita$tot_mit_reverse_pop))

eaicc_index <- data.frame(country = eaicc$country, score_per_capita = eaicc_per_capita$score,score = eaicc$score) 
eaicc_index$score <- scale_index(eaicc_index$score)
eaicc_index$score_per_capita <- scale_index(eaicc_index$score_per_capita)

```


```{r}

eaicc_index <- eaicc_index %>%
  arrange(desc(score)) %>%
  mutate(country = factor(country, levels = unique(country)))

index <- ggplot(eaicc_index, aes(country, score, fill = score >= 0)) +
  geom_bar(stat = "identity", width = 0.8) +
  scale_fill_manual(values = c("gray", "lightgreen"), guide = "none") +
  labs(x = "Country", y = "Score") +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.75, hjust = 1),
        axis.title = element_text(size = 12, face = "bold"),
        plot.title = element_text(size = 16, face = "bold"),
        panel.grid.major.y = element_line(color = "gray", linetype = "dotted"),
        panel.background = element_blank()) +
  scale_x_discrete(limits = rev(levels(eaicc_index$country))) +
  ggtitle("EAICC Score per Country")


eaicc_index <- eaicc_index %>%
  arrange(desc(score_per_capita)) %>%
  mutate(country = factor(country, levels = unique(country)))

index_per_capita <- ggplot(eaicc_index, aes(country, score_per_capita, fill = score_per_capita >= 0)) +
  geom_bar(stat = "identity", width = 0.8) +
  scale_fill_manual(values = c("gray", "lightgreen"),guide = "none") +
  labs(x = "Country", y = "Score") +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.75, hjust = 1),
        axis.title = element_text(size = 12, face = "bold"),
        plot.title = element_text(size = 16, face = "bold"),
        panel.grid.major.y = element_line(color = "gray", linetype = "dotted"),
        panel.grid.minor = element_blank(),
        panel.background = element_blank()) +
  scale_x_discrete(limits = rev(levels(eaicc_index$country))) +
  ggtitle("EAICC Score per Country and Capita")

index
index_per_capita

ggsave("plots/index.png", plot = index, width = 10, height = 6, dpi = 300)
ggsave("plots/index_per_capita.png", plot = index_per_capita, width = 10, height = 6, dpi = 300)



```

- Normieren auf Emissionen auf Personen und Senken auf Fläche
- Ein absoluter Plot
- Overall Score berechnen von den EU Länder 
- Gewichtung anpassen
- Abstände zu Net-Zero Linie
- klassifizieren von den Index-Werten (5 Werte)
